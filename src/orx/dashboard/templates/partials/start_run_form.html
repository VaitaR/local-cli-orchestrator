<div class="modal-header">
    <h3>üöÄ Start New Run</h3>
    <button class="modal-close" onclick="document.getElementById('modal').classList.remove('active')">&times;</button>
</div>
<form id="start-run-form" class="form">
    <div class="form-group">
        <label for="task">üìù Task Description *</label>
        <textarea id="task" 
                  rows="6" 
                  required
                  placeholder="Describe what you want to accomplish..."></textarea>
        <small>Or use @filepath to read from file</small>
    </div>
    
    <div class="form-group">
        <label for="repo_path">üìÅ Repository Path</label>
        <input type="text" 
               id="repo_path" 
               value="{{ default_repo_path }}"
               placeholder="Current directory if empty">
    </div>
    
    <div class="form-group">
        <label for="base_branch">üåø Base Branch</label>
        <input type="text" 
               id="base_branch" 
               placeholder="main">
    </div>
    
    <!-- Pipeline Selection -->
    <div class="form-group">
        <label for="pipeline">üîÄ Pipeline</label>
        <div style="display: flex; gap: 0.5rem; align-items: center;">
            <select id="pipeline" style="flex: 1;">
                <option value="">Loading...</option>
            </select>
            <button type="button" 
                    id="pipeline-preview-btn"
                    class="btn btn-sm btn-secondary"
                    title="Preview Pipeline"
                    style="padding: 0.4rem 0.6rem; font-size: 0.8rem;">
                üëÅÔ∏è
            </button>
            <button type="button" 
                    id="pipeline-customize-btn"
                    class="btn btn-sm btn-secondary"
                    title="Customize Pipeline"
                    style="padding: 0.4rem 0.6rem; font-size: 0.8rem;">
                ‚úèÔ∏è
            </button>
        </div>
        <small>Workflow stages and order</small>
    </div>

    <!-- Pipeline Preview Panel (collapsed by default) -->
    <div id="pipeline-preview-panel" style="display: none; margin-bottom: 1rem;">
        <div style="background: var(--bg-secondary, #f5f5f5); border-radius: 8px; padding: 1rem; border: 1px solid var(--border-color, #e0e0e0);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                <strong id="pipeline-preview-title">Pipeline Preview</strong>
                <button type="button" 
                        onclick="document.getElementById('pipeline-preview-panel').style.display='none'"
                        style="background: none; border: none; cursor: pointer; font-size: 1rem;">‚úï</button>
            </div>
            <p id="pipeline-preview-description" style="font-size: 0.85rem; color: var(--text-secondary, #666); margin-bottom: 0.75rem;"></p>
            <div id="pipeline-preview-nodes" style="display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center;">
                <!-- Nodes rendered here -->
            </div>
        </div>
    </div>
    
    <div class="form-group">
        <label for="engine">‚öôÔ∏è Engine</label>
        <select id="engine">
            <option value="">Loading...</option>
        </select>
        <small>Executor to use for all stages</small>
    </div>

    <div class="form-group" id="global-model-group" style="display: none;">
        <label for="model">ü§ñ Default Model</label>
        <select id="model">
            <option value="">Default</option>
        </select>
        <small id="model-description"></small>
    </div>

    <div class="form-group" id="reasoning-group" style="display: none;">
        <label for="reasoning_effort">üß† Reasoning Effort</label>
        <select id="reasoning_effort">
            <option value="">Default</option>
        </select>
        <small>Higher reasoning = better quality but slower/costlier</small>
    </div>

    <div class="form-group" id="thinking-budget-group" style="display: none;">
        <label for="thinking_budget">üí≠ Thinking Budget</label>
        <div style="display: flex; gap: 0.5rem; align-items: center;">
            <input type="range" 
                   id="thinking_budget_slider" 
                   min="0" 
                   max="32768" 
                   step="1024" 
                   value="8192"
                   style="flex: 1;">
            <input type="number" 
                   id="thinking_budget" 
                   min="0" 
                   max="32768" 
                   step="1024" 
                   value=""
                   placeholder="Default"
                   style="width: 80px;">
        </div>
        <small style="color: #888;">‚ö†Ô∏è Note: Thinking budget requires modelConfigs in Gemini settings.json</small>
    </div>
    
    <details class="form-group" id="per-stage-config">
        <summary style="cursor: pointer; font-weight: 500; margin-bottom: 0.5rem;">
            üîß Advanced: Per-Stage Configuration
        </summary>
        <div id="stage-config-grid" 
             style="display: flex; flex-direction: column; gap: 1rem; margin-top: 0.5rem;">
            <!-- Dynamically populated -->
        </div>
    </details>
    
    <div class="form-actions">
        <button type="button" 
                class="btn btn-secondary"
                onclick="document.getElementById('modal').classList.remove('active')">
            ‚úï Cancel
        </button>
        <button type="submit" class="btn btn-primary">
            ‚ñ∂Ô∏è Start Run
        </button>
    </div>
</form>

<!-- Pipeline Editor Modal -->
<div id="pipeline-editor-modal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 2000;">
    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--bg-primary, white); border-radius: 12px; width: 90%; max-width: 700px; max-height: 85vh; overflow: hidden; box-shadow: 0 20px 50px rgba(0,0,0,0.3);">
        <div style="padding: 1rem 1.5rem; border-bottom: 1px solid var(--border-color, #e0e0e0); display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin: 0;">‚úèÔ∏è Customize Pipeline</h3>
            <button type="button" onclick="closePipelineEditor()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-secondary, #666);">√ó</button>
        </div>
        
        <div style="padding: 1.5rem; overflow-y: auto; max-height: calc(85vh - 140px);">
            <div class="form-group">
                <label for="custom-pipeline-name">Pipeline Name</label>
                <input type="text" id="custom-pipeline-name" placeholder="my-custom-pipeline">
                <small>Leave empty to use for this run only (not saved)</small>
            </div>
            
            <div class="form-group">
                <label for="custom-pipeline-description">Description</label>
                <input type="text" id="custom-pipeline-description" placeholder="Description of this pipeline">
            </div>
            
            <div class="form-group">
                <label>Pipeline Nodes</label>
                <div id="pipeline-nodes-editor" style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <!-- Nodes rendered here -->
                </div>
                <button type="button" id="add-node-btn" class="btn btn-sm btn-secondary" style="margin-top: 0.75rem;">
                    + Add Node
                </button>
            </div>
        </div>
        
        <div style="padding: 1rem 1.5rem; border-top: 1px solid var(--border-color, #e0e0e0); display: flex; justify-content: flex-end; gap: 0.5rem;">
            <button type="button" class="btn btn-secondary" onclick="closePipelineEditor()">Cancel</button>
            <button type="button" class="btn btn-primary" onclick="applyCustomPipeline()">Apply</button>
            <button type="button" class="btn btn-primary" onclick="saveCustomPipeline()" id="save-pipeline-btn">Save as New</button>
        </div>
    </div>
</div>

<!-- Add Node Modal -->
<div id="add-node-modal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 2100;">
    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--bg-primary, white); border-radius: 12px; width: 90%; max-width: 500px; max-height: 80vh; overflow: hidden; box-shadow: 0 20px 50px rgba(0,0,0,0.3);">
        <div style="padding: 1rem 1.5rem; border-bottom: 1px solid var(--border-color, #e0e0e0); display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin: 0;">Add Pipeline Node</h3>
            <button type="button" onclick="closeAddNodeModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer;">√ó</button>
        </div>
        
        <div style="padding: 1.5rem; overflow-y: auto; max-height: calc(80vh - 130px);">
            <div class="form-group">
                <label for="new-node-id">Node ID *</label>
                <input type="text" id="new-node-id" placeholder="e.g., plan, verify, my_gate">
            </div>
            
            <div class="form-group">
                <label for="new-node-type">Node Type *</label>
                <select id="new-node-type">
                    <option value="">Select type...</option>
                    <option value="llm_text">üìù LLM Text (plan, spec, review)</option>
                    <option value="llm_apply">‚öôÔ∏è LLM Apply (implement)</option>
                    <option value="gate">‚úì Gate (verify)</option>
                    <option value="map">üîÄ Map (parallel work items)</option>
                    <option value="custom">üîß Custom Function</option>
                </select>
            </div>
            
            <div class="form-group" id="new-node-template-group" style="display: none;">
                <label for="new-node-template">Template</label>
                <select id="new-node-template">
                    <option value="">Select template...</option>
                </select>
            </div>
            
            <div class="form-group" id="new-node-gates-group" style="display: none;">
                <label>Gates</label>
                <div id="new-node-gates-checkboxes" style="display: flex; flex-direction: column; gap: 0.5rem;">
                    <!-- Populated dynamically -->
                </div>
            </div>
        </div>
        
        <div style="padding: 1rem 1.5rem; border-top: 1px solid var(--border-color, #e0e0e0); display: flex; justify-content: flex-end; gap: 0.5rem;">
            <button type="button" class="btn btn-secondary" onclick="closeAddNodeModal()">Cancel</button>
            <button type="button" class="btn btn-primary" onclick="confirmAddNode()">Add Node</button>
        </div>
    </div>
</div>

<script>
(function() {
    // Cache for engine config
    let engineConfig = null;
    
    // Cache for pipelines data
    let pipelinesCache = null;
    let nodeTypesCache = null;
    let availableGatesCache = null;
    let templatesCache = null;
    
    // Current custom pipeline being edited
    let customPipelineNodes = [];
    
    // Load pipelines from API
    async function loadPipelines() {
        if (pipelinesCache) return pipelinesCache;
        
        try {
            const cached = sessionStorage.getItem('orx_pipelines');
            if (cached) {
                pipelinesCache = JSON.parse(cached);
                return pipelinesCache;
            }
        } catch (e) {
            console.debug('Failed to read pipelines from sessionStorage', e);
        }
        
        try {
            const response = await fetch('/api/pipelines');
            if (!response.ok) {
                console.error('Failed to load pipelines');
                return { pipelines: [] };
            }
            pipelinesCache = await response.json();
            
            try {
                sessionStorage.setItem('orx_pipelines', JSON.stringify(pipelinesCache));
            } catch (e) {
                console.debug('Failed to cache pipelines', e);
            }
            
            return pipelinesCache;
        } catch (error) {
            console.error('Error loading pipelines:', error);
            return { pipelines: [] };
        }
    }
    
    // Load node types
    async function loadNodeTypes() {
        if (nodeTypesCache) return nodeTypesCache;
        
        try {
            const response = await fetch('/api/node-types');
            if (response.ok) {
                nodeTypesCache = await response.json();
            }
        } catch (e) {
            console.debug('Failed to load node types', e);
        }
        return nodeTypesCache || { node_types: [] };
    }
    
    // Load available gates
    async function loadAvailableGates() {
        if (availableGatesCache) return availableGatesCache;
        
        try {
            const response = await fetch('/api/available-gates');
            if (response.ok) {
                availableGatesCache = await response.json();
            }
        } catch (e) {
            console.debug('Failed to load gates', e);
        }
        return availableGatesCache || { gates: [] };
    }
    
    // Load templates
    async function loadTemplates() {
        if (templatesCache) return templatesCache;
        
        try {
            const response = await fetch('/api/templates');
            if (response.ok) {
                templatesCache = await response.json();
            }
        } catch (e) {
            console.debug('Failed to load templates', e);
        }
        return templatesCache || { templates: [] };
    }

    function getBoolDataAttr(el, name) {
        return el?.dataset?.[name] === '1';
    }

    function setBoolDataAttr(el, name, value) {
        if (!el || !el.dataset) return;
        el.dataset[name] = value ? '1' : '0';
    }
    
    // Load engine configuration from API (with session caching)
    async function loadEngineConfig() {
        if (engineConfig) return engineConfig;

        // Try sessionStorage cache first to avoid repeated network calls
        try {
            const cached = sessionStorage.getItem('orx_engine_config');
            if (cached) {
                engineConfig = JSON.parse(cached);
                return engineConfig;
            }
        } catch (e) {
            console.debug('Failed to read engine config from sessionStorage', e);
        }

        try {
            const response = await fetch('/api/config/engines');
            if (!response.ok) {
                console.error('Failed to load engine config');
                return null;
            }
            engineConfig = await response.json();

            // Cache into sessionStorage for the browser session
            try {
                sessionStorage.setItem('orx_engine_config', JSON.stringify(engineConfig));
            } catch (e) {
                console.debug('Failed to write engine config to sessionStorage', e);
            }

            return engineConfig;
        } catch (error) {
            console.error('Error loading engine config:', error);
            return null;
        }
    }
    
    // ====== PIPELINE FUNCTIONS ======
    
    // Get icon for node type
    function getNodeIcon(nodeType) {
        const icons = {
            'llm_text': 'üìù',
            'llm_apply': '‚öôÔ∏è',
            'gate': '‚úì',
            'map': 'üîÄ',
            'custom': 'üîß'
        };
        return icons[nodeType] || 'üì¶';
    }
    
    // Populate pipeline select
    function populatePipelineSelect(pipelines) {
        const select = document.getElementById('pipeline');
        if (!select) return;
        
        select.innerHTML = '';
        
        const defaultOpt = document.createElement('option');
        defaultOpt.value = '';
        defaultOpt.textContent = 'standard (default)';
        select.appendChild(defaultOpt);
        
        for (const pipeline of pipelines) {
            if (pipeline.id === 'standard') continue; // Already default
            
            const opt = document.createElement('option');
            opt.value = pipeline.id;
            opt.textContent = pipeline.id;
            if (pipeline.description) {
                opt.textContent += ` - ${pipeline.description}`;
            }
            if (pipeline.is_builtin === false) {
                opt.textContent += ' (custom)';
            }
            // Store full pipeline data
            opt.dataset.pipeline = JSON.stringify(pipeline);
            select.appendChild(opt);
        }
    }
    
    // Render pipeline preview
    function renderPipelinePreview(pipeline) {
        const panel = document.getElementById('pipeline-preview-panel');
        const title = document.getElementById('pipeline-preview-title');
        const description = document.getElementById('pipeline-preview-description');
        const nodesContainer = document.getElementById('pipeline-preview-nodes');
        
        if (!panel || !pipeline) return;
        
        title.textContent = `Pipeline: ${pipeline.id}`;
        description.textContent = pipeline.description || 'No description';
        
        nodesContainer.innerHTML = '';
        
        const nodes = pipeline.nodes || [];
        nodes.forEach((node, index) => {
            if (index > 0) {
                const arrow = document.createElement('span');
                arrow.textContent = '‚Üí';
                arrow.style.cssText = 'color: var(--text-secondary, #888); font-size: 1.2rem;';
                nodesContainer.appendChild(arrow);
            }
            
            const nodeEl = document.createElement('div');
            nodeEl.style.cssText = 'display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.25rem 0.5rem; background: var(--bg-primary, white); border: 1px solid var(--border-color, #ddd); border-radius: 4px; font-size: 0.8rem;';
            nodeEl.innerHTML = `<span>${getNodeIcon(node.type)}</span><span>${node.id}</span>`;
            nodeEl.title = `Type: ${node.type}${node.template ? `, Template: ${node.template}` : ''}`;
            nodesContainer.appendChild(nodeEl);
        });
        
        panel.style.display = 'block';
    }
    
    // Get current pipeline data
    function getCurrentPipeline() {
        const select = document.getElementById('pipeline');
        if (!select) return null;
        
        const selectedOpt = select.selectedOptions[0];
        if (!selectedOpt || !selectedOpt.value) {
            // Return standard pipeline from cache
            if (pipelinesCache && pipelinesCache.pipelines) {
                return pipelinesCache.pipelines.find(p => p.id === 'standard');
            }
            return null;
        }
        
        // Try to get from data attribute
        if (selectedOpt.dataset.pipeline) {
            try {
                return JSON.parse(selectedOpt.dataset.pipeline);
            } catch (e) {
                console.error('Failed to parse pipeline data', e);
            }
        }
        
        // Fallback: find in cache
        if (pipelinesCache && pipelinesCache.pipelines) {
            return pipelinesCache.pipelines.find(p => p.id === selectedOpt.value);
        }
        
        return null;
    }
    
    // ====== PIPELINE EDITOR FUNCTIONS ======
    
    // Open pipeline editor
    function openPipelineEditor() {
        const pipeline = getCurrentPipeline();
        if (!pipeline) {
            alert('No pipeline selected');
            return;
        }
        
        // Clone nodes for editing
        customPipelineNodes = JSON.parse(JSON.stringify(pipeline.nodes || []));
        
        // Populate editor
        document.getElementById('custom-pipeline-name').value = '';
        document.getElementById('custom-pipeline-description').value = pipeline.description || '';
        
        renderPipelineNodesEditor();
        
        document.getElementById('pipeline-editor-modal').style.display = 'block';
    }
    
    // Close pipeline editor
    window.closePipelineEditor = function() {
        document.getElementById('pipeline-editor-modal').style.display = 'none';
        customPipelineNodes = [];
    };
    
    // Render nodes in editor
    function renderPipelineNodesEditor() {
        const container = document.getElementById('pipeline-nodes-editor');
        if (!container) return;
        
        container.innerHTML = '';
        
        customPipelineNodes.forEach((node, index) => {
            const nodeEl = document.createElement('div');
            nodeEl.className = 'pipeline-node-item';
            nodeEl.style.cssText = 'display: flex; align-items: center; gap: 0.5rem; padding: 0.75rem; background: var(--bg-secondary, #f5f5f5); border-radius: 6px; border: 1px solid var(--border-color, #e0e0e0);';
            
            nodeEl.innerHTML = `
                <span style="font-size: 1.2rem;">${getNodeIcon(node.type)}</span>
                <div style="flex: 1; min-width: 0;">
                    <div style="font-weight: 600; font-size: 0.9rem;">${node.id}</div>
                    <div style="font-size: 0.75rem; color: var(--text-secondary, #666);">
                        ${node.type}${node.template ? ` ‚Ä¢ ${node.template}` : ''}${node.gates ? ` ‚Ä¢ gates: ${node.gates.join(', ')}` : ''}
                    </div>
                </div>
                <div style="display: flex; gap: 0.25rem;">
                    <button type="button" class="btn btn-sm" onclick="moveNodeUp(${index})" ${index === 0 ? 'disabled' : ''} style="padding: 0.2rem 0.4rem;">‚Üë</button>
                    <button type="button" class="btn btn-sm" onclick="moveNodeDown(${index})" ${index === customPipelineNodes.length - 1 ? 'disabled' : ''} style="padding: 0.2rem 0.4rem;">‚Üì</button>
                    <button type="button" class="btn btn-sm btn-danger" onclick="removeNode(${index})" style="padding: 0.2rem 0.4rem;">‚úï</button>
                </div>
            `;
            
            container.appendChild(nodeEl);
        });
    }
    
    // Move node up
    window.moveNodeUp = function(index) {
        if (index <= 0) return;
        const temp = customPipelineNodes[index];
        customPipelineNodes[index] = customPipelineNodes[index - 1];
        customPipelineNodes[index - 1] = temp;
        renderPipelineNodesEditor();
    };
    
    // Move node down
    window.moveNodeDown = function(index) {
        if (index >= customPipelineNodes.length - 1) return;
        const temp = customPipelineNodes[index];
        customPipelineNodes[index] = customPipelineNodes[index + 1];
        customPipelineNodes[index + 1] = temp;
        renderPipelineNodesEditor();
    };
    
    // Remove node
    window.removeNode = function(index) {
        customPipelineNodes.splice(index, 1);
        renderPipelineNodesEditor();
    };
    
    // ====== ADD NODE MODAL ======
    
    // Open add node modal
    async function openAddNodeModal() {
        // Load templates for the select
        const templatesData = await loadTemplates();
        const templateSelect = document.getElementById('new-node-template');
        templateSelect.innerHTML = '<option value="">Select template...</option>';
        for (const tpl of templatesData.templates) {
            const opt = document.createElement('option');
            opt.value = tpl.id;
            opt.textContent = tpl.name;
            templateSelect.appendChild(opt);
        }
        
        // Load gates for checkboxes
        const gatesData = await loadAvailableGates();
        const gatesContainer = document.getElementById('new-node-gates-checkboxes');
        gatesContainer.innerHTML = '';
        for (const gate of gatesData.gates) {
            const label = document.createElement('label');
            label.style.cssText = 'display: flex; align-items: center; gap: 0.5rem;';
            label.innerHTML = `
                <input type="checkbox" name="new-node-gate" value="${gate.id}" ${gate.default_enabled ? 'checked' : ''}>
                <span>${gate.label}</span>
                <small style="color: var(--text-secondary, #666);">${gate.description}</small>
            `;
            gatesContainer.appendChild(label);
        }
        
        // Reset form
        document.getElementById('new-node-id').value = '';
        document.getElementById('new-node-type').value = '';
        document.getElementById('new-node-template-group').style.display = 'none';
        document.getElementById('new-node-gates-group').style.display = 'none';
        
        document.getElementById('add-node-modal').style.display = 'block';
    }
    
    // Close add node modal
    window.closeAddNodeModal = function() {
        document.getElementById('add-node-modal').style.display = 'none';
    };
    
    // Handle node type change
    document.getElementById('new-node-type').addEventListener('change', function() {
        const type = this.value;
        const templateGroup = document.getElementById('new-node-template-group');
        const gatesGroup = document.getElementById('new-node-gates-group');
        
        // Show template for LLM types
        templateGroup.style.display = (type === 'llm_text' || type === 'llm_apply') ? 'block' : 'none';
        
        // Show gates for gate type
        gatesGroup.style.display = (type === 'gate') ? 'block' : 'none';
    });
    
    // Confirm add node
    window.confirmAddNode = function() {
        const nodeId = document.getElementById('new-node-id').value.trim();
        const nodeType = document.getElementById('new-node-type').value;
        
        if (!nodeId) {
            alert('Node ID is required');
            return;
        }
        if (!nodeType) {
            alert('Node type is required');
            return;
        }
        
        // Check for duplicate ID
        if (customPipelineNodes.some(n => n.id === nodeId)) {
            alert('A node with this ID already exists');
            return;
        }
        
        const node = {
            id: nodeId,
            type: nodeType
        };
        
        // Add template if applicable
        if (nodeType === 'llm_text' || nodeType === 'llm_apply') {
            const template = document.getElementById('new-node-template').value;
            if (template) {
                node.template = template;
            }
        }
        
        // Add gates if applicable
        if (nodeType === 'gate') {
            const checkedGates = [...document.querySelectorAll('input[name="new-node-gate"]:checked')].map(cb => cb.value);
            if (checkedGates.length > 0) {
                node.gates = checkedGates;
            }
        }
        
        customPipelineNodes.push(node);
        renderPipelineNodesEditor();
        closeAddNodeModal();
    };
    
    // ====== APPLY/SAVE PIPELINE ======
    
    // Apply custom pipeline (for this run only)
    window.applyCustomPipeline = function() {
        if (customPipelineNodes.length === 0) {
            alert('Pipeline must have at least one node');
            return;
        }
        
        // Store custom nodes in form data attribute
        const form = document.getElementById('start-run-form');
        form.dataset.customPipeline = JSON.stringify({
            nodes: customPipelineNodes
        });
        
        // Update pipeline select to show custom
        const select = document.getElementById('pipeline');
        
        // Check if custom option exists
        let customOpt = select.querySelector('option[value="__custom__"]');
        if (!customOpt) {
            customOpt = document.createElement('option');
            customOpt.value = '__custom__';
            select.appendChild(customOpt);
        }
        
        customOpt.textContent = `Custom (${customPipelineNodes.length} nodes)`;
        customOpt.dataset.pipeline = JSON.stringify({
            id: '__custom__',
            description: 'Custom pipeline for this run',
            nodes: customPipelineNodes
        });
        
        select.value = '__custom__';
        
        // Show preview
        renderPipelinePreview({
            id: '__custom__',
            description: 'Custom pipeline for this run',
            nodes: customPipelineNodes
        });
        
        closePipelineEditor();
    };
    
    // Save custom pipeline to server
    window.saveCustomPipeline = async function() {
        const name = document.getElementById('custom-pipeline-name').value.trim();
        const description = document.getElementById('custom-pipeline-description').value.trim();
        
        if (!name) {
            alert('Pipeline name is required to save');
            return;
        }
        
        if (customPipelineNodes.length === 0) {
            alert('Pipeline must have at least one node');
            return;
        }
        
        // Validate name format
        if (!/^[a-z][a-z0-9_-]*$/.test(name)) {
            alert('Pipeline name must start with lowercase letter and contain only lowercase letters, numbers, underscores, and hyphens');
            return;
        }
        
        const pipeline = {
            id: name,
            description: description || null,
            nodes: customPipelineNodes
        };
        
        try {
            const response = await fetch('/api/pipelines', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(pipeline)
            });
            
            if (!response.ok) {
                const error = await response.json();
                alert(`Failed to save pipeline: ${error.detail || 'Unknown error'}`);
                return;
            }
            
            // Clear cache to reload pipelines
            sessionStorage.removeItem('orx_pipelines');
            pipelinesCache = null;
            
            // Reload pipelines
            const data = await loadPipelines();
            populatePipelineSelect(data.pipelines);
            
            // Select new pipeline
            document.getElementById('pipeline').value = name;
            
            closePipelineEditor();
            
            alert(`Pipeline "${name}" saved successfully!`);
        } catch (error) {
            console.error('Error saving pipeline:', error);
            alert(`Error: ${error.message}`);
        }
    };
    
    // ====== END PIPELINE FUNCTIONS ======
    
    // Populate engine select dropdown
    function populateEngineSelect(selectId, engines, includeDefault = true, includeTest = false) {
        const select = document.getElementById(selectId);
        if (!select) return;
        
        select.innerHTML = '';
        
        if (includeDefault) {
            const defaultOpt = document.createElement('option');
            defaultOpt.value = '';
            defaultOpt.textContent = selectId === 'engine' ? 'Default (from orx.yaml)' : 'Default';
            select.appendChild(defaultOpt);
        }
        
        for (const engine of engines) {
            if (!includeTest && engine.is_test) continue;
            
            const opt = document.createElement('option');
            opt.value = engine.value;
            opt.textContent = engine.label;
            if (engine.is_test) {
                opt.textContent += ' (testing)';
            }
            select.appendChild(opt);
        }
    }

    // Populate model select dropdown with capabilities
    function populateModelSelect(select, models, defaultValue = '') {
        if (!select) return;
        select.innerHTML = '';

        const hasModels = Array.isArray(models) && models.length > 0;
        select.disabled = !hasModels;
        
        const defaultOpt = document.createElement('option');
        defaultOpt.value = '';
        defaultOpt.textContent = 'Default';
        select.appendChild(defaultOpt);
        
        for (const model of models) {
            const opt = document.createElement('option');
            // Support both string and object models
            const modelId = typeof model === 'string' ? model : model.id;
            const modelName = typeof model === 'string' ? model : (model.name || model.id);
            
            opt.value = modelId;
            opt.textContent = modelName;
            
            // Store capabilities in data attributes if available
            if (typeof model === 'object') {
                opt.dataset.supportsReasoning = model.supports_reasoning ? '1' : '0';
                opt.dataset.supportsThinkingBudget = model.supports_thinking_budget ? '1' : '0';
                opt.dataset.maxThinkingBudget = model.max_thinking_budget || '0';
                opt.dataset.defaultThinkingBudget = model.default_thinking_budget || '0';
                opt.dataset.reasoningLevels = JSON.stringify(model.reasoning_levels || []);
                opt.dataset.description = model.description || '';
                opt.dataset.tier = model.tier || '2';
            }
            
            if (modelId === defaultValue) {
                opt.selected = true;
            }
            select.appendChild(opt);
        }
        
        // Debug: log first model's capabilities
        if (models.length > 0 && typeof models[0] === 'object') {
            console.log('Model capabilities loaded:', {
                id: models[0].id,
                supports_reasoning: models[0].supports_reasoning,
                supports_thinking_budget: models[0].supports_thinking_budget
            });
        }
    }

    // Update reasoning/thinking controls based on selected model
    function updateModelCapabilityControls(modelSelect, engineValue) {
        const selectedOption = modelSelect.selectedOptions[0];
        const reasoningGroup = document.getElementById('reasoning-group');
        const thinkingBudgetGroup = document.getElementById('thinking-budget-group');
        const reasoningSelect = document.getElementById('reasoning_effort');
        const thinkingBudgetSlider = document.getElementById('thinking_budget_slider');
        const thinkingBudgetInput = document.getElementById('thinking_budget');
        const modelDescription = document.getElementById('model-description');
        
        // Reset visibility
        reasoningGroup.style.display = 'none';
        thinkingBudgetGroup.style.display = 'none';
        
        if (!selectedOption || !selectedOption.value) {
            modelDescription.textContent = 'Model to use for all stages (unless overridden below)';
            return;
        }
        
        // Update description
        const description = selectedOption.dataset.description;
        modelDescription.textContent = description || 'Model to use for all stages (unless overridden below)';
        
        // Check for reasoning support (Codex)
        const supportsReasoning = selectedOption.dataset.supportsReasoning === '1';
        if (supportsReasoning && engineValue === 'codex') {
            reasoningGroup.style.display = 'block';
            
            // Populate reasoning levels
            const levels = JSON.parse(selectedOption.dataset.reasoningLevels || '[]');
            reasoningSelect.innerHTML = '<option value="">Default</option>';
            for (const level of levels) {
                const opt = document.createElement('option');
                opt.value = level;
                opt.textContent = level.charAt(0).toUpperCase() + level.slice(1);
                reasoningSelect.appendChild(opt);
            }
        }
        
        // Check for thinking budget support (Gemini)
        const supportsThinkingBudget = selectedOption.dataset.supportsThinkingBudget === '1';
        if (supportsThinkingBudget && engineValue === 'gemini') {
            thinkingBudgetGroup.style.display = 'block';
            
            const maxBudget = parseInt(selectedOption.dataset.maxThinkingBudget) || 32768;
            const defaultBudget = parseInt(selectedOption.dataset.defaultThinkingBudget) || 8192;
            
            thinkingBudgetSlider.max = maxBudget;
            thinkingBudgetSlider.value = defaultBudget;
            thinkingBudgetInput.max = maxBudget;
            thinkingBudgetInput.placeholder = `Default: ${defaultBudget}`;
        }
    }
    
    // Update reasoning options for a per-stage selector based on model capabilities
    function updateStageReasoningOptions(modelSelect, engineValue, reasoningSelect) {
        const selectedOption = modelSelect.selectedOptions[0];
        
        // Reset to disabled state
        reasoningSelect.disabled = true;
        reasoningSelect.style.opacity = '0.5';
        reasoningSelect.innerHTML = '<option value="">Default</option>';
        
        if (!selectedOption || !selectedOption.value || engineValue !== 'codex') {
            return;
        }
        
        // Check if model supports reasoning
        const supportsReasoning = selectedOption.dataset.supportsReasoning === '1';
        if (!supportsReasoning) {
            return;
        }
        
        // Get available reasoning levels for this model
        const levels = JSON.parse(selectedOption.dataset.reasoningLevels || '[]');
        if (levels.length === 0) {
            return;
        }
        
        // Enable and populate reasoning select
        reasoningSelect.disabled = false;
        reasoningSelect.style.opacity = '1';
        
        const currentValue = reasoningSelect.value;
        const defaultReasoning = selectedOption.dataset.defaultReasoning || 'medium';
        
        // Keep "Default" option
        reasoningSelect.innerHTML = '<option value="">Default</option>';
        
        // Add available levels
        for (const level of levels) {
            const opt = document.createElement('option');
            opt.value = level;
            opt.textContent = level.charAt(0).toUpperCase() + level.slice(1);
            reasoningSelect.appendChild(opt);
        }
        
        // Try to restore previous selection, or fall back to valid default
        if (currentValue && levels.includes(currentValue)) {
            reasoningSelect.value = currentValue;
        } else if (currentValue && !levels.includes(currentValue)) {
            // Previous selection not available - reset to default or first available
            if (levels.includes(defaultReasoning)) {
                reasoningSelect.value = '';  // Use default
            } else {
                reasoningSelect.value = levels[0];  // First available
            }
        }
    }
    
    // Get production engines (non-test only)
    function getProductionEngines(engines) {
        return engines.filter(e => !e.is_test);
    }
    
    // Build per-stage configuration grid dynamically
    function buildStageConfigGrid(stages, engines) {
        const grid = document.getElementById('stage-config-grid');
        if (!grid) return;
        
        grid.innerHTML = '';
        
        // Filter out stages that shouldn't be configurable
        const configurableStages = stages.filter(s => 
            !['knowledge_update'].includes(s.value)
        );
        
        for (const stage of configurableStages) {
            const row = document.createElement('div');
            row.className = 'stage-config-row';
            row.style.display = 'grid';
            row.style.gridTemplateColumns = '100px 1fr 1.2fr 1fr';
            row.style.gap = '0.5rem';
            row.style.alignItems = 'center';
            row.style.padding = '0.5rem';
            row.style.background = 'rgba(0,0,0,0.05)';
            row.style.borderRadius = '4px';
            
            const label = document.createElement('label');
            label.style.fontSize = '0.8rem';
            label.style.fontWeight = '600';
            label.style.whiteSpace = 'nowrap';
            label.style.overflow = 'hidden';
            label.style.textOverflow = 'ellipsis';
            label.title = stage.label;
            label.textContent = stage.label;
            
            // Engine Select
            const engineSelect = document.createElement('select');
            engineSelect.id = `engine_${stage.value}`;
            engineSelect.className = 'stage-engine-select';
            engineSelect.style.fontSize = '0.8rem';
            engineSelect.style.minWidth = '0';
            engineSelect.dataset.stage = stage.value;
            
            const defaultOpt = document.createElement('option');
            defaultOpt.value = '';
            defaultOpt.textContent = 'Inherit';
            engineSelect.appendChild(defaultOpt);
            
            for (const engine of engines) {
                const opt = document.createElement('option');
                opt.value = engine.value;
                opt.textContent = engine.label;
                engineSelect.appendChild(opt);
            }
            
            // Model Select
            const modelSelect = document.createElement('select');
            modelSelect.id = `model_${stage.value}`;
            modelSelect.className = 'stage-model-select';
            modelSelect.style.fontSize = '0.8rem';
            modelSelect.style.minWidth = '0';
            modelSelect.dataset.stage = stage.value;
            
            const modelDefaultOpt = document.createElement('option');
            modelDefaultOpt.value = '';
            modelDefaultOpt.textContent = 'Default';
            modelSelect.appendChild(modelDefaultOpt);

            // Track whether a user has overridden this stage.
            setBoolDataAttr(engineSelect, 'overridden', false);
            setBoolDataAttr(modelSelect, 'overridden', false);
            
            engineSelect.addEventListener('change', (e) => {
                const globalEngineSelect = document.getElementById('engine');
                const globalEngine = globalEngineSelect ? globalEngineSelect.value : '';
                const selectedEngineValue = engineSelect.value;

                if (e.isTrusted) {
                    const overridden = Boolean(selectedEngineValue) && selectedEngineValue !== globalEngine;
                    setBoolDataAttr(engineSelect, 'overridden', overridden);
                    setBoolDataAttr(modelSelect, 'overridden', false);
                }

                const effectiveEngine = selectedEngineValue || globalEngine;
                const selectedEngine = engines.find(e => e.value === effectiveEngine);
                // Use full models data if available
                const availableModels = selectedEngine ? (selectedEngine.models || selectedEngine.available_models) : [];
                const stageDefaultModel = selectedEngine ? (selectedEngine.stage_models[stage.value] || '') : '';
                populateModelSelect(modelSelect, availableModels, stageDefaultModel);
                
                // Update reasoning options when engine changes
                const reasoningSelect = document.getElementById(`reasoning_effort_${stage.value}`);
                if (reasoningSelect) {
                    updateStageReasoningOptions(modelSelect, effectiveEngine, reasoningSelect);
                }
            });

            modelSelect.addEventListener('change', (e) => {
                if (!e.isTrusted) return;
                const globalEngineSelect = document.getElementById('engine');
                const globalModelSelect = document.getElementById('model');
                const globalEngine = globalEngineSelect ? globalEngineSelect.value : '';
                const globalModel = globalModelSelect ? globalModelSelect.value : '';

                const stageEngine = engineSelect.value;
                const modelValue = modelSelect.value;
                const effectiveEngine = stageEngine || globalEngine;

                let overridden = false;
                if (modelValue) {
                    if (!globalEngine || !globalModel) {
                        overridden = true;
                    } else {
                        overridden = !(effectiveEngine === globalEngine && modelValue === globalModel);
                    }
                }
                setBoolDataAttr(modelSelect, 'overridden', overridden);
                
                // Update reasoning effort options for this stage based on selected model
                const reasoningSelect = document.getElementById(`reasoning_effort_${stage.value}`);
                if (reasoningSelect) {
                    updateStageReasoningOptions(modelSelect, effectiveEngine, reasoningSelect);
                }
            });
            
            // Reasoning Effort Select (per-stage)
            const reasoningSelect = document.createElement('select');
            reasoningSelect.id = `reasoning_effort_${stage.value}`;
            reasoningSelect.name = `stages.${stage.value}.reasoning_effort`;
            reasoningSelect.className = 'stage-reasoning-select';
            reasoningSelect.style.fontSize = '0.8rem';
            reasoningSelect.style.minWidth = '0';
            reasoningSelect.dataset.stage = stage.value;
            
            const reasoningDefaultOpt = document.createElement('option');
            reasoningDefaultOpt.value = '';
            reasoningDefaultOpt.textContent = 'Default';
            reasoningSelect.appendChild(reasoningDefaultOpt);
            
            // Initially hidden until model with reasoning support is selected
            reasoningSelect.disabled = true;
            reasoningSelect.style.opacity = '0.5';
            
            row.appendChild(label);
            row.appendChild(engineSelect);
            row.appendChild(modelSelect);
            row.appendChild(reasoningSelect);
            grid.appendChild(row);
        }
    }
    
    // Initialize form
    async function initForm() {
        const config = await loadEngineConfig();
        const fallbackEngines = [
            { value: 'codex', label: 'Codex', is_test: false, models: [], available_models: [], stage_models: {} },
            { value: 'gemini', label: 'Gemini', is_test: false, models: [], available_models: [], stage_models: {} },
            { value: 'fake', label: 'Fake', is_test: true, models: [], available_models: [], stage_models: {} }
        ];
        const engines = config ? config.engines : fallbackEngines;
        const stages = config ? config.stages : [];
        
        const productionEngines = getProductionEngines(engines);
        populateEngineSelect('engine', productionEngines, true, false);
        
        // Load and populate pipelines
        const pipelinesData = await loadPipelines();
        populatePipelineSelect(pipelinesData.pipelines || []);
        
        // Pipeline select change handler
        const pipelineSelect = document.getElementById('pipeline');
        pipelineSelect.addEventListener('change', () => {
            const pipeline = getCurrentPipeline();
            if (pipeline) {
                renderPipelinePreview(pipeline);
            } else {
                document.getElementById('pipeline-preview-panel').style.display = 'none';
            }
        });
        
        // Pipeline preview button
        document.getElementById('pipeline-preview-btn').addEventListener('click', () => {
            const panel = document.getElementById('pipeline-preview-panel');
            if (panel.style.display === 'none' || !panel.style.display) {
                const pipeline = getCurrentPipeline();
                if (pipeline) {
                    renderPipelinePreview(pipeline);
                }
            } else {
                panel.style.display = 'none';
            }
        });
        
        // Pipeline customize button
        document.getElementById('pipeline-customize-btn').addEventListener('click', openPipelineEditor);
        
        // Add node button
        document.getElementById('add-node-btn').addEventListener('click', openAddNodeModal);

        const perStageDetails = document.getElementById('per-stage-config');
        if (stages.length > 0) {
            buildStageConfigGrid(stages, productionEngines);
        } else {
            if (perStageDetails) {
                perStageDetails.style.display = 'none';
            }
        }

        const globalEngineSelect = document.getElementById('engine');
        const globalModelSelect = document.getElementById('model');
        const globalModelGroup = document.getElementById('global-model-group');
        
        // Thinking budget slider sync
        const thinkingBudgetSlider = document.getElementById('thinking_budget_slider');
        const thinkingBudgetInput = document.getElementById('thinking_budget');
        
        thinkingBudgetSlider.addEventListener('input', () => {
            thinkingBudgetInput.value = thinkingBudgetSlider.value;
        });
        
        thinkingBudgetInput.addEventListener('input', () => {
            if (thinkingBudgetInput.value) {
                thinkingBudgetSlider.value = thinkingBudgetInput.value;
            }
        });

        // Global engine change handler
        globalEngineSelect.addEventListener('change', (e) => {
            const globalEngine = e.target.value;
            const reasoningGroup = document.getElementById('reasoning-group');
            const thinkingBudgetGroup = document.getElementById('thinking-budget-group');
            
            if (!globalEngine) {
                globalModelGroup.style.display = 'none';
                globalModelSelect.value = '';
                reasoningGroup.style.display = 'none';
                thinkingBudgetGroup.style.display = 'none';

                document.querySelectorAll('.stage-engine-select').forEach(select => {
                    select.value = '';
                    setBoolDataAttr(select, 'overridden', false);

                    const stage = select.dataset.stage;
                    const modelSelect = document.getElementById(`model_${stage}`);
                    if (modelSelect) {
                        populateModelSelect(modelSelect, []);
                        modelSelect.value = '';
                        setBoolDataAttr(modelSelect, 'overridden', false);
                    }
                });
                return;
            }

            const selectedEngineData = engines.find(eng => eng.value === globalEngine);
            
            // Update global model select with full model data
            const availableModels = selectedEngineData ? (selectedEngineData.models || selectedEngineData.available_models) : [];
            if (availableModels.length > 0) {
                globalModelGroup.style.display = 'block';
                populateModelSelect(globalModelSelect, availableModels);
                
                // Trigger capability controls update if a model is already selected
                if (globalModelSelect.value) {
                    updateModelCapabilityControls(globalModelSelect, globalEngine);
                }
            } else {
                globalModelGroup.style.display = 'none';
                globalModelSelect.value = '';
            }
            
            // Reset reasoning/thinking controls
            reasoningGroup.style.display = 'none';
            thinkingBudgetGroup.style.display = 'none';

            // Sync per-stage selects
            document.querySelectorAll('.stage-engine-select').forEach(select => {
                select.value = globalEngine;
                setBoolDataAttr(select, 'overridden', false);
                const stage = select.dataset.stage;
                const modelSelect = document.getElementById(`model_${stage}`);
                const reasoningSelect = document.getElementById(`reasoning_effort_${stage}`);
                if (selectedEngineData) {
                    const defaultModel = selectedEngineData.stage_models[stage] || '';
                    populateModelSelect(modelSelect, availableModels, defaultModel);
                    setBoolDataAttr(modelSelect, 'overridden', false);
                    // Update reasoning options for the synced model
                    if (reasoningSelect) {
                        updateStageReasoningOptions(modelSelect, globalEngine, reasoningSelect);
                    }
                } else {
                    populateModelSelect(modelSelect, []);
                    setBoolDataAttr(modelSelect, 'overridden', false);
                    // Disable reasoning when no engine
                    if (reasoningSelect) {
                        reasoningSelect.disabled = true;
                        reasoningSelect.style.opacity = '0.5';
                    }
                }
            });
        });

        // Global model change handler
        globalModelSelect.addEventListener('change', (e) => {
            const globalModel = e.target.value;
            const globalEngine = globalEngineSelect.value;
            
            // Update reasoning/thinking controls based on model capabilities
            updateModelCapabilityControls(globalModelSelect, globalEngine);
            
            if (!globalModel) return;

            document.querySelectorAll('.stage-model-select').forEach(select => {
                const stage = select.dataset.stage;
                const engineSelect = document.getElementById(`engine_${stage}`);
                const isOverridden = getBoolDataAttr(select, 'overridden');
                const effectiveEngine = (engineSelect.value || globalEngineSelect.value);
                if (effectiveEngine === globalEngineSelect.value && !isOverridden) {
                    select.value = globalModel;
                }
            });
        });

        // Initialize defaults from API
        if (config && config.default_engine) {
            globalEngineSelect.value = config.default_engine;
            globalEngineSelect.dispatchEvent(new Event('change'));
        }
    }
    
    // Collect per-stage overrides
    function collectStageOverrides() {
        const stages = {};
        const grid = document.getElementById('stage-config-grid');
        if (!grid) return stages;
        
        const configurable_stages = [...new Set([...grid.querySelectorAll('select')].map(s => s.dataset.stage))];
        
        for (const stageName of configurable_stages) {
            const engineValue = document.getElementById(`engine_${stageName}`).value;
            const modelValue = document.getElementById(`model_${stageName}`).value;
            const reasoningValue = document.getElementById(`reasoning_effort_${stageName}`).value;

            const engineSelect = document.getElementById(`engine_${stageName}`);
            const modelSelect = document.getElementById(`model_${stageName}`);
            const reasoningSelect = document.getElementById(`reasoning_effort_${stageName}`);
            
            const engineOverridden = getBoolDataAttr(engineSelect, 'overridden');
            const modelOverridden = getBoolDataAttr(modelSelect, 'overridden');
            
            // Reasoning is overridden if value is set and control is enabled (not disabled)
            const reasoningOverridden = reasoningValue && !reasoningSelect.disabled;

            if (!engineOverridden && !modelOverridden && !reasoningOverridden) {
                continue;
            }

            if (engineValue || modelValue || reasoningOverridden) {
                stages[stageName] = {};
                if (engineOverridden && engineValue) stages[stageName].executor = engineValue;
                if (modelOverridden && modelValue) stages[stageName].model = modelValue;
                if (reasoningOverridden) stages[stageName].reasoning_effort = reasoningValue;
            }
        }
        
        return stages;
    }
    
    // Form submit handler
    document.getElementById('start-run-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const task = document.getElementById('task').value;
        const repo_path = document.getElementById('repo_path').value || null;
        const base_branch = document.getElementById('base_branch').value || null;
        const engine = document.getElementById('engine').value || null;
        const model = document.getElementById('model').value || null;
        const reasoning_effort = document.getElementById('reasoning_effort').value || null;
        const thinking_budget_raw = document.getElementById('thinking_budget').value;
        const thinking_budget = thinking_budget_raw ? parseInt(thinking_budget_raw) : null;
        
        // Get selected pipeline
        const pipelineSelect = document.getElementById('pipeline');
        let pipeline = pipelineSelect.value || null;
        let pipeline_override = null;
        
        // Check for custom pipeline
        if (pipeline === '__custom__') {
            const form = document.getElementById('start-run-form');
            if (form.dataset.customPipeline) {
                try {
                    pipeline_override = JSON.parse(form.dataset.customPipeline);
                    pipeline = null; // Don't pass ID, use override
                } catch (e) {
                    console.error('Failed to parse custom pipeline', e);
                }
            }
        }
        
        // Build config_overrides
        const config_overrides = {};
        
        if (engine) {
            config_overrides.engine = engine;
        }

        if (model) {
            config_overrides.model = model;
        }

        if (reasoning_effort) {
            config_overrides.reasoning_effort = reasoning_effort;
        }

        if (thinking_budget !== null) {
            config_overrides.thinking_budget = thinking_budget;
        }
        
        const stages_config = collectStageOverrides();
        if (Object.keys(stages_config).length > 0) {
            config_overrides.stages = stages_config;
        }
        
        console.log('Submitting form with:', { task, repo_path, base_branch, engine, pipeline, config_overrides });
        
        try {
            const requestBody = {
                task: task,
                repo_path: repo_path,
                base_branch: base_branch,
                config_overrides: config_overrides
            };
            
            // Add pipeline if selected (not default)
            if (pipeline) {
                requestBody.pipeline = pipeline;
            }
            
            // Add pipeline override for custom pipelines
            if (pipeline_override) {
                requestBody.pipeline_override = pipeline_override;
            }
            
            const response = await fetch('/api/runs/start', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody)
            });
            
            if (!response.ok) {
                let error_detail = 'Failed to start run';
                try {
                    const error = await response.json();
                    error_detail = error.detail || JSON.stringify(error);
                } catch (e) {
                    const text = await response.text();
                    error_detail = `HTTP ${response.status}: ${text.substring(0, 200)}`;
                }
                console.error('API Error:', error_detail);
                alert(`Error: ${error_detail}`);
                return;
            }
            
            const result = await response.json();
            console.log('Run started:', result);
            
            document.getElementById('modal').classList.remove('active');
            
            const notification = document.createElement('div');
            notification.className = 'notification success';
            notification.innerHTML = `‚úì Run started: <a href="/runs/${result.run_id}" style="color:white;text-decoration:underline">${result.run_id}</a>`;
            notification.style.cssText = 'position:fixed;top:1rem;right:1rem;background:#22c55e;color:white;padding:1rem;border-radius:0.5rem;z-index:1000;box-shadow:0 4px 6px rgba(0,0,0,0.1);';
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 5000);
            
            htmx.ajax('GET', '/partials/active-runs', {target: '#active-runs', swap: 'innerHTML'});
            htmx.ajax('GET', '/partials/recent-runs', {target: '#recent-runs', swap: 'innerHTML'});
            
        } catch (error) {
            console.error('Request error:', error);
            alert(`Error: ${error.message}`);
        }
    });
    
    initForm();
})();
</script>
