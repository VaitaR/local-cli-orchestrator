<div class="modal-header">
    <h3>üöÄ Start New Run</h3>
    <button class="modal-close" onclick="document.getElementById('modal').classList.remove('active')">&times;</button>
</div>
<form id="start-run-form" class="form">
    <div class="form-group">
        <label for="task">üìù Task Description *</label>
        <textarea id="task" 
                  rows="6" 
                  required
                  placeholder="Describe what you want to accomplish..."></textarea>
        <small>Or use @filepath to read from file</small>
    </div>
    
    <div class="form-group">
        <label for="repo_path">üìÅ Repository Path</label>
        <input type="text" 
               id="repo_path" 
               value="{{ default_repo_path }}"
               placeholder="Current directory if empty">
    </div>
    
    <div class="form-group">
        <label for="base_branch">üåø Base Branch</label>
        <input type="text" 
               id="base_branch" 
               placeholder="main">
    </div>
    
    <div class="form-group">
        <label for="engine">‚öôÔ∏è Engine</label>
        <select id="engine">
            <option value="">Loading...</option>
        </select>
        <small>Executor to use for all stages</small>
    </div>

    <div class="form-group" id="global-model-group" style="display: none;">
        <label for="model">ü§ñ Default Model</label>
        <select id="model">
            <option value="">Default</option>
        </select>
        <small>Model to use for all stages (unless overridden below)</small>
    </div>
    
    <details class="form-group" id="per-stage-config">
        <summary style="cursor: pointer; font-weight: 500; margin-bottom: 0.5rem;">
            üîß Advanced: Per-Stage Configuration
        </summary>
        <div id="stage-config-grid" 
             style="display: flex; flex-direction: column; gap: 1rem; margin-top: 0.5rem;">
            <!-- Dynamically populated -->
        </div>
    </details>
    
    <div class="form-actions">
        <button type="button" 
                class="btn btn-secondary"
                onclick="document.getElementById('modal').classList.remove('active')">
            ‚úï Cancel
        </button>
        <button type="submit" class="btn btn-primary">
            ‚ñ∂Ô∏è Start Run
        </button>
    </div>
</form>

<script>
(function() {
    // Cache for engine config
    let engineConfig = null;

    function getBoolDataAttr(el, name) {
        return el?.dataset?.[name] === '1';
    }

    function setBoolDataAttr(el, name, value) {
        if (!el || !el.dataset) return;
        el.dataset[name] = value ? '1' : '0';
    }
    
    // Load engine configuration from API
    async function loadEngineConfig() {
        if (engineConfig) return engineConfig;
        
        try {
            const response = await fetch('/api/config/engines');
            if (!response.ok) {
                console.error('Failed to load engine config');
                return null;
            }
            engineConfig = await response.json();
            return engineConfig;
        } catch (error) {
            console.error('Error loading engine config:', error);
            return null;
        }
    }
    
    // Populate engine select dropdown
    function populateEngineSelect(selectId, engines, includeDefault = true, includeTest = false) {
        const select = document.getElementById(selectId);
        if (!select) return;
        
        select.innerHTML = '';
        
        if (includeDefault) {
            const defaultOpt = document.createElement('option');
            defaultOpt.value = '';
            defaultOpt.textContent = selectId === 'engine' ? 'Default (from orx.yaml)' : 'Default';
            select.appendChild(defaultOpt);
        }
        
        for (const engine of engines) {
            if (!includeTest && engine.is_test) continue;
            
            const opt = document.createElement('option');
            opt.value = engine.value;
            opt.textContent = engine.label;
            if (engine.is_test) {
                opt.textContent += ' (testing)';
            }
            select.appendChild(opt);
        }
    }

    // Populate model select dropdown
    function populateModelSelect(select, models, defaultValue = '') {
        if (!select) return;
        select.innerHTML = '';

        const hasModels = Array.isArray(models) && models.length > 0;
        select.disabled = !hasModels;
        
        const defaultOpt = document.createElement('option');
        defaultOpt.value = '';
        defaultOpt.textContent = 'Default';
        select.appendChild(defaultOpt);
        
        for (const model of models) {
            const opt = document.createElement('option');
            opt.value = model;
            opt.textContent = model;
            if (model === defaultValue) {
                opt.selected = true;
            }
            select.appendChild(opt);
        }
    }
    
    // Get production engines (non-test only)
    function getProductionEngines(engines) {
        return engines.filter(e => !e.is_test);
    }
    
    // Build per-stage configuration grid dynamically
    function buildStageConfigGrid(stages, engines) {
        const grid = document.getElementById('stage-config-grid');
        if (!grid) return;
        
        grid.innerHTML = '';
        
        // Filter out stages that shouldn't be configurable
        const configurableStages = stages.filter(s => 
            !['knowledge_update'].includes(s.value)
        );
        
        for (const stage of configurableStages) {
            const row = document.createElement('div');
            row.className = 'stage-config-row';
            row.style.display = 'grid';
            row.style.gridTemplateColumns = '120px 1fr 1fr';
            row.style.gap = '0.5rem';
            row.style.alignItems = 'center';
            row.style.padding = '0.5rem';
            row.style.background = 'rgba(0,0,0,0.05)';
            row.style.borderRadius = '4px';
            
            const label = document.createElement('label');
            label.style.fontSize = '0.85rem';
            label.style.fontWeight = '600';
            label.textContent = stage.label;
            
            // Engine Select
            const engineSelect = document.createElement('select');
            engineSelect.id = `engine_${stage.value}`;
            engineSelect.className = 'stage-engine-select';
            engineSelect.style.fontSize = '0.85rem';
            engineSelect.dataset.stage = stage.value;
            
            const defaultOpt = document.createElement('option');
            defaultOpt.value = '';
            defaultOpt.textContent = 'Engine: Inherit';
            engineSelect.appendChild(defaultOpt);
            
            for (const engine of engines) {
                const opt = document.createElement('option');
                opt.value = engine.value;
                opt.textContent = engine.label;
                engineSelect.appendChild(opt);
            }
            
            // Model Select
            const modelSelect = document.createElement('select');
            modelSelect.id = `model_${stage.value}`;
            modelSelect.className = 'stage-model-select';
            modelSelect.style.fontSize = '0.85rem';
            modelSelect.dataset.stage = stage.value;
            
            const modelDefaultOpt = document.createElement('option');
            modelDefaultOpt.value = '';
            modelDefaultOpt.textContent = 'Model: Default';
            modelSelect.appendChild(modelDefaultOpt);

            // Track whether a user has overridden this stage.
            // Programmatic updates do not dispatch change events, so this is safe.
            setBoolDataAttr(engineSelect, 'overridden', false);
            setBoolDataAttr(modelSelect, 'overridden', false);
            
            engineSelect.addEventListener('change', (e) => {
                const globalEngineSelect = document.getElementById('engine');
                const globalEngine = globalEngineSelect ? globalEngineSelect.value : '';
                const selectedEngineValue = engineSelect.value;

                // If user explicitly sets a stage engine, treat it as override unless
                // it matches the global engine (then it's equivalent to inherit).
                if (e.isTrusted) {
                    const overridden = Boolean(selectedEngineValue) && selectedEngineValue !== globalEngine;
                    setBoolDataAttr(engineSelect, 'overridden', overridden);

                    // Changing the engine resets any prior model override.
                    setBoolDataAttr(modelSelect, 'overridden', false);
                }

                // Resolve which engine's model list should be shown.
                const effectiveEngine = selectedEngineValue || globalEngine;
                const selectedEngine = engines.find(e => e.value === effectiveEngine);
                const availableModels = selectedEngine ? selectedEngine.available_models : [];
                const stageDefaultModel = selectedEngine ? (selectedEngine.stage_models[stage.value] || '') : '';
                populateModelSelect(modelSelect, availableModels, stageDefaultModel);
            });

            modelSelect.addEventListener('change', (e) => {
                if (!e.isTrusted) return;
                const globalEngineSelect = document.getElementById('engine');
                const globalModelSelect = document.getElementById('model');
                const globalEngine = globalEngineSelect ? globalEngineSelect.value : '';
                const globalModel = globalModelSelect ? globalModelSelect.value : '';

                const stageEngine = engineSelect.value;
                const modelValue = modelSelect.value;
                const effectiveEngine = stageEngine || globalEngine;

                // A manual selection is considered an override unless it is
                // effectively identical to the global selection.
                let overridden = false;
                if (modelValue) {
                    if (!globalEngine || !globalModel) {
                        overridden = true;
                    } else {
                        overridden = !(effectiveEngine === globalEngine && modelValue === globalModel);
                    }
                }
                setBoolDataAttr(modelSelect, 'overridden', overridden);
            });
            
            row.appendChild(label);
            row.appendChild(engineSelect);
            row.appendChild(modelSelect);
            grid.appendChild(row);
        }
    }
    
    // Initialize form
    async function initForm() {
        const config = await loadEngineConfig();
        const fallbackEngines = [
            { value: 'codex', label: 'Codex', is_test: false, available_models: [], stage_models: {} },
            { value: 'gemini', label: 'Gemini', is_test: false, available_models: [], stage_models: {} },
            { value: 'fake', label: 'Fake', is_test: true, available_models: [], stage_models: {} }
        ];
        const engines = config ? config.engines : fallbackEngines;
        const stages = config ? config.stages : [];
        
        const productionEngines = getProductionEngines(engines);
        populateEngineSelect('engine', productionEngines, true, false);

        const perStageDetails = document.getElementById('per-stage-config');
        if (stages.length > 0) {
            buildStageConfigGrid(stages, productionEngines);
        } else {
            // Stages are intentionally loaded from the API so the frontend does not
            // need to know the stage list ahead of time.
            if (perStageDetails) {
                perStageDetails.style.display = 'none';
            }
        }

        const globalEngineSelect = document.getElementById('engine');
        const globalModelSelect = document.getElementById('model');
        const globalModelGroup = document.getElementById('global-model-group');

        // Global engine change handler: sync per-stage configs
        globalEngineSelect.addEventListener('change', (e) => {
            const globalEngine = e.target.value;
            if (!globalEngine) {
                globalModelGroup.style.display = 'none';
                globalModelSelect.value = '';

                // Reset per-stage selects to inherited defaults.
                document.querySelectorAll('.stage-engine-select').forEach(select => {
                    select.value = '';
                    setBoolDataAttr(select, 'overridden', false);

                    const stage = select.dataset.stage;
                    const modelSelect = document.getElementById(`model_${stage}`);
                    if (modelSelect) {
                        populateModelSelect(modelSelect, []);
                        modelSelect.value = '';
                        setBoolDataAttr(modelSelect, 'overridden', false);
                    }
                });
                return;
            }

            const selectedEngineData = engines.find(eng => eng.value === globalEngine);
            
            // Update global model select
            if (selectedEngineData && selectedEngineData.available_models.length > 0) {
                globalModelGroup.style.display = 'block';
                populateModelSelect(globalModelSelect, selectedEngineData.available_models);
            } else {
                globalModelGroup.style.display = 'none';
                globalModelSelect.value = '';
            }

            // Sync per-stage selects
            document.querySelectorAll('.stage-engine-select').forEach(select => {
                select.value = globalEngine;
                setBoolDataAttr(select, 'overridden', false);
                const stage = select.dataset.stage;
                const modelSelect = document.getElementById(`model_${stage}`);
                if (selectedEngineData) {
                    const defaultModel = selectedEngineData.stage_models[stage] || '';
                    populateModelSelect(modelSelect, selectedEngineData.available_models, defaultModel);
                    setBoolDataAttr(modelSelect, 'overridden', false);
                } else {
                    populateModelSelect(modelSelect, []);
                    setBoolDataAttr(modelSelect, 'overridden', false);
                }
            });
        });

        // Global model change handler: sync per-stage models
        globalModelSelect.addEventListener('change', (e) => {
            const globalModel = e.target.value;
            if (!globalModel) return;

            document.querySelectorAll('.stage-model-select').forEach(select => {
                // Only sync if the engine matches the global engine
                const stage = select.dataset.stage;
                const engineSelect = document.getElementById(`engine_${stage}`);
                const isOverridden = getBoolDataAttr(select, 'overridden');
                const effectiveEngine = (engineSelect.value || globalEngineSelect.value);
                if (effectiveEngine === globalEngineSelect.value && !isOverridden) {
                    select.value = globalModel;
                }
            });
        });

        // Initialize defaults from API (if provided)
        if (config && config.default_engine) {
            globalEngineSelect.value = config.default_engine;
            globalEngineSelect.dispatchEvent(new Event('change'));
        }
    }
    
    // Collect per-stage overrides
    function collectStageOverrides() {
        const stages = {};
        const grid = document.getElementById('stage-config-grid');
        if (!grid) return stages;
        
        const configurable_stages = [...new Set([...grid.querySelectorAll('select')].map(s => s.dataset.stage))];
        
        for (const stageName of configurable_stages) {
            const engineValue = document.getElementById(`engine_${stageName}`).value;
            const modelValue = document.getElementById(`model_${stageName}`).value;

            const engineSelect = document.getElementById(`engine_${stageName}`);
            const modelSelect = document.getElementById(`model_${stageName}`);
            const engineOverridden = getBoolDataAttr(engineSelect, 'overridden');
            const modelOverridden = getBoolDataAttr(modelSelect, 'overridden');

            if (!engineOverridden && !modelOverridden) {
                continue;
            }

            if (engineValue || modelValue) {
                stages[stageName] = {};
                if (engineOverridden && engineValue) stages[stageName].executor = engineValue;
                if (modelOverridden && modelValue) stages[stageName].model = modelValue;
            }
        }
        
        return stages;
    }
    
    // Form submit handler
    document.getElementById('start-run-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const task = document.getElementById('task').value;
        const repo_path = document.getElementById('repo_path').value || null;
        const base_branch = document.getElementById('base_branch').value || null;
        const engine = document.getElementById('engine').value || null;
        const model = document.getElementById('model').value || null;
        
        // Build config_overrides
        const config_overrides = {};
        
        // Global engine override
        if (engine) {
            config_overrides.engine = engine;
        }

        // Global model override
        if (model) {
            config_overrides.model = model;
        }
        
        // Per-stage engine/model overrides
        const stages_config = collectStageOverrides();
        if (Object.keys(stages_config).length > 0) {
            config_overrides.stages = stages_config;
        }
        
        console.log('Submitting form with:', { task, repo_path, base_branch, engine, config_overrides });
        
        try {
            const response = await fetch('/api/runs/start', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    task: task,
                    repo_path: repo_path,
                    base_branch: base_branch,
                    config_overrides: config_overrides
                })
            });
            
            if (!response.ok) {
                let error_detail = 'Failed to start run';
                try {
                    const error = await response.json();
                    error_detail = error.detail || JSON.stringify(error);
                } catch (e) {
                    const text = await response.text();
                    error_detail = `HTTP ${response.status}: ${text.substring(0, 200)}`;
                }
                console.error('API Error:', error_detail);
                alert(`Error: ${error_detail}`);
                return;
            }
            
            const result = await response.json();
            console.log('Run started:', result);
            
            // Close modal
            document.getElementById('modal').classList.remove('active');
            
            // Show success notification
            const notification = document.createElement('div');
            notification.className = 'notification success';
            notification.innerHTML = `‚úì Run started: <a href="/runs/${result.run_id}" style="color:white;text-decoration:underline">${result.run_id}</a>`;
            notification.style.cssText = 'position:fixed;top:1rem;right:1rem;background:#22c55e;color:white;padding:1rem;border-radius:0.5rem;z-index:1000;box-shadow:0 4px 6px rgba(0,0,0,0.1);';
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 5000);
            
            // Refresh the runs list
            htmx.ajax('GET', '/partials/active-runs', {target: '#active-runs', swap: 'innerHTML'});
            htmx.ajax('GET', '/partials/recent-runs', {target: '#recent-runs', swap: 'innerHTML'});
            
        } catch (error) {
            console.error('Request error:', error);
            alert(`Error: ${error.message}`);
        }
    });
    
    // Initialize on load
    initForm();
})();
</script>
