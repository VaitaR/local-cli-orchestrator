<div class="modal-header">
    <h3>üöÄ Start New Run</h3>
    <button class="modal-close" onclick="document.getElementById('modal').classList.remove('active')">&times;</button>
</div>
<form id="start-run-form" class="form">
    <div class="form-group">
        <label for="task">üìù Task Description *</label>
        <textarea id="task" 
                  rows="6" 
                  required
                  placeholder="Describe what you want to accomplish..."></textarea>
        <small>Or use @filepath to read from file</small>
    </div>
    
    <div class="form-group">
        <label for="repo_path">üìÅ Repository Path</label>
        <input type="text" 
               id="repo_path" 
               value="{{ default_repo_path }}"
               placeholder="Current directory if empty">
    </div>
    
    <div class="form-group">
        <label for="base_branch">üåø Base Branch</label>
        <input type="text" 
               id="base_branch" 
               placeholder="main">
    </div>
    
    <div class="form-group">
        <label for="engine">‚öôÔ∏è Engine</label>
        <select id="engine">
            <option value="">Loading...</option>
        </select>
        <small>Executor to use for all stages</small>
    </div>

    <div class="form-group" id="global-model-group" style="display: none;">
        <label for="model">ü§ñ Default Model</label>
        <select id="model">
            <option value="">Default</option>
        </select>
        <small id="model-description"></small>
    </div>

    <div class="form-group" id="reasoning-group" style="display: none;">
        <label for="reasoning_effort">üß† Reasoning Effort</label>
        <select id="reasoning_effort">
            <option value="">Default</option>
        </select>
        <small>Higher reasoning = better quality but slower/costlier</small>
    </div>

    <div class="form-group" id="thinking-budget-group" style="display: none;">
        <label for="thinking_budget">üí≠ Thinking Budget</label>
        <div style="display: flex; gap: 0.5rem; align-items: center;">
            <input type="range" 
                   id="thinking_budget_slider" 
                   min="0" 
                   max="32768" 
                   step="1024" 
                   value="8192"
                   style="flex: 1;">
            <input type="number" 
                   id="thinking_budget" 
                   min="0" 
                   max="32768" 
                   step="1024" 
                   value=""
                   placeholder="Default"
                   style="width: 80px;">
        </div>
        <small>Tokens for model thinking (0 = disabled, blank = default)</small>
    </div>
    
    <details class="form-group" id="per-stage-config">
        <summary style="cursor: pointer; font-weight: 500; margin-bottom: 0.5rem;">
            üîß Advanced: Per-Stage Configuration
        </summary>
        <div id="stage-config-grid" 
             style="display: flex; flex-direction: column; gap: 1rem; margin-top: 0.5rem;">
            <!-- Dynamically populated -->
        </div>
    </details>
    
    <div class="form-actions">
        <button type="button" 
                class="btn btn-secondary"
                onclick="document.getElementById('modal').classList.remove('active')">
            ‚úï Cancel
        </button>
        <button type="submit" class="btn btn-primary">
            ‚ñ∂Ô∏è Start Run
        </button>
    </div>
</form>

<script>
(function() {
    // Cache for engine config
    let engineConfig = null;

    function getBoolDataAttr(el, name) {
        return el?.dataset?.[name] === '1';
    }

    function setBoolDataAttr(el, name, value) {
        if (!el || !el.dataset) return;
        el.dataset[name] = value ? '1' : '0';
    }
    
    // Load engine configuration from API
    async function loadEngineConfig() {
        if (engineConfig) return engineConfig;
        
        try {
            const response = await fetch('/api/config/engines');
            if (!response.ok) {
                console.error('Failed to load engine config');
                return null;
            }
            engineConfig = await response.json();
            return engineConfig;
        } catch (error) {
            console.error('Error loading engine config:', error);
            return null;
        }
    }
    
    // Populate engine select dropdown
    function populateEngineSelect(selectId, engines, includeDefault = true, includeTest = false) {
        const select = document.getElementById(selectId);
        if (!select) return;
        
        select.innerHTML = '';
        
        if (includeDefault) {
            const defaultOpt = document.createElement('option');
            defaultOpt.value = '';
            defaultOpt.textContent = selectId === 'engine' ? 'Default (from orx.yaml)' : 'Default';
            select.appendChild(defaultOpt);
        }
        
        for (const engine of engines) {
            if (!includeTest && engine.is_test) continue;
            
            const opt = document.createElement('option');
            opt.value = engine.value;
            opt.textContent = engine.label;
            if (engine.is_test) {
                opt.textContent += ' (testing)';
            }
            select.appendChild(opt);
        }
    }

    // Populate model select dropdown with capabilities
    function populateModelSelect(select, models, defaultValue = '') {
        if (!select) return;
        select.innerHTML = '';

        const hasModels = Array.isArray(models) && models.length > 0;
        select.disabled = !hasModels;
        
        const defaultOpt = document.createElement('option');
        defaultOpt.value = '';
        defaultOpt.textContent = 'Default';
        select.appendChild(defaultOpt);
        
        for (const model of models) {
            const opt = document.createElement('option');
            // Support both string and object models
            const modelId = typeof model === 'string' ? model : model.id;
            const modelName = typeof model === 'string' ? model : (model.name || model.id);
            
            opt.value = modelId;
            opt.textContent = modelName;
            
            // Store capabilities in data attributes if available
            if (typeof model === 'object') {
                opt.dataset.supportsReasoning = model.supports_reasoning ? '1' : '0';
                opt.dataset.supportsThinkingBudget = model.supports_thinking_budget ? '1' : '0';
                opt.dataset.maxThinkingBudget = model.max_thinking_budget || '0';
                opt.dataset.defaultThinkingBudget = model.default_thinking_budget || '0';
                opt.dataset.reasoningLevels = JSON.stringify(model.reasoning_levels || []);
                opt.dataset.description = model.description || '';
                opt.dataset.tier = model.tier || '2';
            }
            
            if (modelId === defaultValue) {
                opt.selected = true;
            }
            select.appendChild(opt);
        }
    }

    // Update reasoning/thinking controls based on selected model
    function updateModelCapabilityControls(modelSelect, engineValue) {
        const selectedOption = modelSelect.selectedOptions[0];
        const reasoningGroup = document.getElementById('reasoning-group');
        const thinkingBudgetGroup = document.getElementById('thinking-budget-group');
        const reasoningSelect = document.getElementById('reasoning_effort');
        const thinkingBudgetSlider = document.getElementById('thinking_budget_slider');
        const thinkingBudgetInput = document.getElementById('thinking_budget');
        const modelDescription = document.getElementById('model-description');
        
        // Reset visibility
        reasoningGroup.style.display = 'none';
        thinkingBudgetGroup.style.display = 'none';
        
        if (!selectedOption || !selectedOption.value) {
            modelDescription.textContent = 'Model to use for all stages (unless overridden below)';
            return;
        }
        
        // Update description
        const description = selectedOption.dataset.description;
        modelDescription.textContent = description || 'Model to use for all stages (unless overridden below)';
        
        // Check for reasoning support (Codex)
        const supportsReasoning = selectedOption.dataset.supportsReasoning === '1';
        if (supportsReasoning && engineValue === 'codex') {
            reasoningGroup.style.display = 'block';
            
            // Populate reasoning levels
            const levels = JSON.parse(selectedOption.dataset.reasoningLevels || '[]');
            reasoningSelect.innerHTML = '<option value="">Default</option>';
            for (const level of levels) {
                const opt = document.createElement('option');
                opt.value = level;
                opt.textContent = level.charAt(0).toUpperCase() + level.slice(1);
                reasoningSelect.appendChild(opt);
            }
        }
        
        // Check for thinking budget support (Gemini)
        const supportsThinkingBudget = selectedOption.dataset.supportsThinkingBudget === '1';
        if (supportsThinkingBudget && engineValue === 'gemini') {
            thinkingBudgetGroup.style.display = 'block';
            
            const maxBudget = parseInt(selectedOption.dataset.maxThinkingBudget) || 32768;
            const defaultBudget = parseInt(selectedOption.dataset.defaultThinkingBudget) || 8192;
            
            thinkingBudgetSlider.max = maxBudget;
            thinkingBudgetSlider.value = defaultBudget;
            thinkingBudgetInput.max = maxBudget;
            thinkingBudgetInput.placeholder = `Default: ${defaultBudget}`;
        }
    }
    
    // Get production engines (non-test only)
    function getProductionEngines(engines) {
        return engines.filter(e => !e.is_test);
    }
    
    // Build per-stage configuration grid dynamically
    function buildStageConfigGrid(stages, engines) {
        const grid = document.getElementById('stage-config-grid');
        if (!grid) return;
        
        grid.innerHTML = '';
        
        // Filter out stages that shouldn't be configurable
        const configurableStages = stages.filter(s => 
            !['knowledge_update'].includes(s.value)
        );
        
        for (const stage of configurableStages) {
            const row = document.createElement('div');
            row.className = 'stage-config-row';
            row.style.display = 'grid';
            row.style.gridTemplateColumns = '100px 1fr 1fr';
            row.style.gap = '0.5rem';
            row.style.alignItems = 'center';
            row.style.padding = '0.5rem';
            row.style.background = 'rgba(0,0,0,0.05)';
            row.style.borderRadius = '4px';
            
            const label = document.createElement('label');
            label.style.fontSize = '0.8rem';
            label.style.fontWeight = '600';
            label.style.whiteSpace = 'nowrap';
            label.style.overflow = 'hidden';
            label.style.textOverflow = 'ellipsis';
            label.title = stage.label;
            label.textContent = stage.label;
            
            // Engine Select
            const engineSelect = document.createElement('select');
            engineSelect.id = `engine_${stage.value}`;
            engineSelect.className = 'stage-engine-select';
            engineSelect.style.fontSize = '0.8rem';
            engineSelect.style.minWidth = '0';
            engineSelect.dataset.stage = stage.value;
            
            const defaultOpt = document.createElement('option');
            defaultOpt.value = '';
            defaultOpt.textContent = 'Inherit';
            engineSelect.appendChild(defaultOpt);
            
            for (const engine of engines) {
                const opt = document.createElement('option');
                opt.value = engine.value;
                opt.textContent = engine.label;
                engineSelect.appendChild(opt);
            }
            
            // Model Select
            const modelSelect = document.createElement('select');
            modelSelect.id = `model_${stage.value}`;
            modelSelect.className = 'stage-model-select';
            modelSelect.style.fontSize = '0.8rem';
            modelSelect.style.minWidth = '0';
            modelSelect.dataset.stage = stage.value;
            
            const modelDefaultOpt = document.createElement('option');
            modelDefaultOpt.value = '';
            modelDefaultOpt.textContent = 'Default';
            modelSelect.appendChild(modelDefaultOpt);

            // Track whether a user has overridden this stage.
            setBoolDataAttr(engineSelect, 'overridden', false);
            setBoolDataAttr(modelSelect, 'overridden', false);
            
            engineSelect.addEventListener('change', (e) => {
                const globalEngineSelect = document.getElementById('engine');
                const globalEngine = globalEngineSelect ? globalEngineSelect.value : '';
                const selectedEngineValue = engineSelect.value;

                if (e.isTrusted) {
                    const overridden = Boolean(selectedEngineValue) && selectedEngineValue !== globalEngine;
                    setBoolDataAttr(engineSelect, 'overridden', overridden);
                    setBoolDataAttr(modelSelect, 'overridden', false);
                }

                const effectiveEngine = selectedEngineValue || globalEngine;
                const selectedEngine = engines.find(e => e.value === effectiveEngine);
                // Use full models data if available
                const availableModels = selectedEngine ? (selectedEngine.models || selectedEngine.available_models) : [];
                const stageDefaultModel = selectedEngine ? (selectedEngine.stage_models[stage.value] || '') : '';
                populateModelSelect(modelSelect, availableModels, stageDefaultModel);
            });

            modelSelect.addEventListener('change', (e) => {
                if (!e.isTrusted) return;
                const globalEngineSelect = document.getElementById('engine');
                const globalModelSelect = document.getElementById('model');
                const globalEngine = globalEngineSelect ? globalEngineSelect.value : '';
                const globalModel = globalModelSelect ? globalModelSelect.value : '';

                const stageEngine = engineSelect.value;
                const modelValue = modelSelect.value;
                const effectiveEngine = stageEngine || globalEngine;

                let overridden = false;
                if (modelValue) {
                    if (!globalEngine || !globalModel) {
                        overridden = true;
                    } else {
                        overridden = !(effectiveEngine === globalEngine && modelValue === globalModel);
                    }
                }
                setBoolDataAttr(modelSelect, 'overridden', overridden);
            });
            
            row.appendChild(label);
            row.appendChild(engineSelect);
            row.appendChild(modelSelect);
            grid.appendChild(row);
        }
    }
    
    // Initialize form
    async function initForm() {
        const config = await loadEngineConfig();
        const fallbackEngines = [
            { value: 'codex', label: 'Codex', is_test: false, models: [], available_models: [], stage_models: {} },
            { value: 'gemini', label: 'Gemini', is_test: false, models: [], available_models: [], stage_models: {} },
            { value: 'fake', label: 'Fake', is_test: true, models: [], available_models: [], stage_models: {} }
        ];
        const engines = config ? config.engines : fallbackEngines;
        const stages = config ? config.stages : [];
        
        const productionEngines = getProductionEngines(engines);
        populateEngineSelect('engine', productionEngines, true, false);

        const perStageDetails = document.getElementById('per-stage-config');
        if (stages.length > 0) {
            buildStageConfigGrid(stages, productionEngines);
        } else {
            if (perStageDetails) {
                perStageDetails.style.display = 'none';
            }
        }

        const globalEngineSelect = document.getElementById('engine');
        const globalModelSelect = document.getElementById('model');
        const globalModelGroup = document.getElementById('global-model-group');
        
        // Thinking budget slider sync
        const thinkingBudgetSlider = document.getElementById('thinking_budget_slider');
        const thinkingBudgetInput = document.getElementById('thinking_budget');
        
        thinkingBudgetSlider.addEventListener('input', () => {
            thinkingBudgetInput.value = thinkingBudgetSlider.value;
        });
        
        thinkingBudgetInput.addEventListener('input', () => {
            if (thinkingBudgetInput.value) {
                thinkingBudgetSlider.value = thinkingBudgetInput.value;
            }
        });

        // Global engine change handler
        globalEngineSelect.addEventListener('change', (e) => {
            const globalEngine = e.target.value;
            const reasoningGroup = document.getElementById('reasoning-group');
            const thinkingBudgetGroup = document.getElementById('thinking-budget-group');
            
            if (!globalEngine) {
                globalModelGroup.style.display = 'none';
                globalModelSelect.value = '';
                reasoningGroup.style.display = 'none';
                thinkingBudgetGroup.style.display = 'none';

                document.querySelectorAll('.stage-engine-select').forEach(select => {
                    select.value = '';
                    setBoolDataAttr(select, 'overridden', false);

                    const stage = select.dataset.stage;
                    const modelSelect = document.getElementById(`model_${stage}`);
                    if (modelSelect) {
                        populateModelSelect(modelSelect, []);
                        modelSelect.value = '';
                        setBoolDataAttr(modelSelect, 'overridden', false);
                    }
                });
                return;
            }

            const selectedEngineData = engines.find(eng => eng.value === globalEngine);
            
            // Update global model select with full model data
            const availableModels = selectedEngineData ? (selectedEngineData.models || selectedEngineData.available_models) : [];
            if (availableModels.length > 0) {
                globalModelGroup.style.display = 'block';
                populateModelSelect(globalModelSelect, availableModels);
            } else {
                globalModelGroup.style.display = 'none';
                globalModelSelect.value = '';
            }
            
            // Reset reasoning/thinking controls
            reasoningGroup.style.display = 'none';
            thinkingBudgetGroup.style.display = 'none';

            // Sync per-stage selects
            document.querySelectorAll('.stage-engine-select').forEach(select => {
                select.value = globalEngine;
                setBoolDataAttr(select, 'overridden', false);
                const stage = select.dataset.stage;
                const modelSelect = document.getElementById(`model_${stage}`);
                if (selectedEngineData) {
                    const defaultModel = selectedEngineData.stage_models[stage] || '';
                    populateModelSelect(modelSelect, availableModels, defaultModel);
                    setBoolDataAttr(modelSelect, 'overridden', false);
                } else {
                    populateModelSelect(modelSelect, []);
                    setBoolDataAttr(modelSelect, 'overridden', false);
                }
            });
        });

        // Global model change handler
        globalModelSelect.addEventListener('change', (e) => {
            const globalModel = e.target.value;
            const globalEngine = globalEngineSelect.value;
            
            // Update reasoning/thinking controls based on model capabilities
            updateModelCapabilityControls(globalModelSelect, globalEngine);
            
            if (!globalModel) return;

            document.querySelectorAll('.stage-model-select').forEach(select => {
                const stage = select.dataset.stage;
                const engineSelect = document.getElementById(`engine_${stage}`);
                const isOverridden = getBoolDataAttr(select, 'overridden');
                const effectiveEngine = (engineSelect.value || globalEngineSelect.value);
                if (effectiveEngine === globalEngineSelect.value && !isOverridden) {
                    select.value = globalModel;
                }
            });
        });

        // Initialize defaults from API
        if (config && config.default_engine) {
            globalEngineSelect.value = config.default_engine;
            globalEngineSelect.dispatchEvent(new Event('change'));
        }
    }
    
    // Collect per-stage overrides
    function collectStageOverrides() {
        const stages = {};
        const grid = document.getElementById('stage-config-grid');
        if (!grid) return stages;
        
        const configurable_stages = [...new Set([...grid.querySelectorAll('select')].map(s => s.dataset.stage))];
        
        for (const stageName of configurable_stages) {
            const engineValue = document.getElementById(`engine_${stageName}`).value;
            const modelValue = document.getElementById(`model_${stageName}`).value;

            const engineSelect = document.getElementById(`engine_${stageName}`);
            const modelSelect = document.getElementById(`model_${stageName}`);
            const engineOverridden = getBoolDataAttr(engineSelect, 'overridden');
            const modelOverridden = getBoolDataAttr(modelSelect, 'overridden');

            if (!engineOverridden && !modelOverridden) {
                continue;
            }

            if (engineValue || modelValue) {
                stages[stageName] = {};
                if (engineOverridden && engineValue) stages[stageName].executor = engineValue;
                if (modelOverridden && modelValue) stages[stageName].model = modelValue;
            }
        }
        
        return stages;
    }
    
    // Form submit handler
    document.getElementById('start-run-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const task = document.getElementById('task').value;
        const repo_path = document.getElementById('repo_path').value || null;
        const base_branch = document.getElementById('base_branch').value || null;
        const engine = document.getElementById('engine').value || null;
        const model = document.getElementById('model').value || null;
        const reasoning_effort = document.getElementById('reasoning_effort').value || null;
        const thinking_budget_raw = document.getElementById('thinking_budget').value;
        const thinking_budget = thinking_budget_raw ? parseInt(thinking_budget_raw) : null;
        
        // Build config_overrides
        const config_overrides = {};
        
        if (engine) {
            config_overrides.engine = engine;
        }

        if (model) {
            config_overrides.model = model;
        }

        if (reasoning_effort) {
            config_overrides.reasoning_effort = reasoning_effort;
        }

        if (thinking_budget !== null) {
            config_overrides.thinking_budget = thinking_budget;
        }
        
        const stages_config = collectStageOverrides();
        if (Object.keys(stages_config).length > 0) {
            config_overrides.stages = stages_config;
        }
        
        console.log('Submitting form with:', { task, repo_path, base_branch, engine, config_overrides });
        
        try {
            const response = await fetch('/api/runs/start', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    task: task,
                    repo_path: repo_path,
                    base_branch: base_branch,
                    config_overrides: config_overrides
                })
            });
            
            if (!response.ok) {
                let error_detail = 'Failed to start run';
                try {
                    const error = await response.json();
                    error_detail = error.detail || JSON.stringify(error);
                } catch (e) {
                    const text = await response.text();
                    error_detail = `HTTP ${response.status}: ${text.substring(0, 200)}`;
                }
                console.error('API Error:', error_detail);
                alert(`Error: ${error_detail}`);
                return;
            }
            
            const result = await response.json();
            console.log('Run started:', result);
            
            document.getElementById('modal').classList.remove('active');
            
            const notification = document.createElement('div');
            notification.className = 'notification success';
            notification.innerHTML = `‚úì Run started: <a href="/runs/${result.run_id}" style="color:white;text-decoration:underline">${result.run_id}</a>`;
            notification.style.cssText = 'position:fixed;top:1rem;right:1rem;background:#22c55e;color:white;padding:1rem;border-radius:0.5rem;z-index:1000;box-shadow:0 4px 6px rgba(0,0,0,0.1);';
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 5000);
            
            htmx.ajax('GET', '/partials/active-runs', {target: '#active-runs', swap: 'innerHTML'});
            htmx.ajax('GET', '/partials/recent-runs', {target: '#recent-runs', swap: 'innerHTML'});
            
        } catch (error) {
            console.error('Request error:', error);
            alert(`Error: ${error.message}`);
        }
    });
    
    initForm();
})();
</script>
